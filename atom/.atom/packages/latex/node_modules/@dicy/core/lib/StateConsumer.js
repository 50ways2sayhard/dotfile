'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _treeKill = require('tree-kill');

var _treeKill2 = _interopRequireDefault(_treeKill);

var _fastGlob = require('fast-glob');

var _fastGlob2 = _interopRequireDefault(_fastGlob);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _State = require('./State');

var _State2 = _interopRequireDefault(_State);

var _File = require('./File');

var _File2 = _interopRequireDefault(_File);

var _Rule = require('./Rule');

var _Rule2 = _interopRequireDefault(_Rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VARIABLE_PATTERN = /\$\{?(\w+)\}?/g;

class StateConsumer {

  constructor(state, options) {
    this.consumerOptions = {};

    this.state = state;
    this.options = new Proxy(options, {
      get: (target, key) => {
        return key in this.consumerOptions ? this.consumerOptions[key] : target[key];
      },
      set: (target, key, value) => {
        this.setOption(this.consumerOptions, key, value);
        return true;
      },
      ownKeys: target => {
        const keys = new _set2.default((0, _keys2.default)(this.consumerOptions));

        (0, _keys2.default)(target).forEach(key => keys.add(key));

        return (0, _from2.default)(keys.values());
      }
    });
    this.env = {
      OUTDIR: this.options.outputDirectory || '.',
      // $FlowIgnore
      OUTEXT: `.${this.options.outputFormat}`,
      JOB: this.options.jobName || this.state.env.NAME
    };
  }

  addTarget(filePath) {
    this.state.targets.add(filePath);
  }

  removeTarget(filePath) {
    this.state.targets.delete(filePath);
  }

  addResolvedTarget(filePath) {
    this.state.targets.add(this.resolvePath(filePath));
  }

  replaceResolvedTarget(oldFilePath, newFilePath) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const x = _this.resolvePath(oldFilePath);
      if (_this.state.targets.has(x)) {
        yield _this.addResolvedTarget(newFilePath);
      }
    })();
  }

  addResolvedTargets(filePaths) {
    for (const filePath of filePaths) {
      this.addResolvedTarget(filePath);
    }
  }

  get killToken() {
    return this.state.killToken;
  }

  set killToken(value) {
    this.state.killToken = value;
  }

  assignOptions(options) {
    for (const name in options) {
      const value = options[name];

      if (name === 'jobs') {
        let jobs = this.state.options.jobs;

        if (!jobs) {
          this.state.options.jobs = jobs = {};
        }

        for (const jobName in value) {
          const subOptions = value[jobName];
          let jobOptions = jobs[jobName];

          if (!jobOptions) {
            jobs[jobName] = jobOptions = {};
          }

          for (const jobOptionName in subOptions) {
            this.setOption(jobOptions, jobOptionName, subOptions[jobOptionName]);
          }
        }
      } else {
        this.setOption(this.state.options, name, value);
      }
    }
  }

  setOption(store, name, value) {
    const schema = this.state.optionSchema.get(name);
    if (schema) {
      let invalidType = false;

      switch (schema.type) {
        case 'string':
          invalidType = typeof value !== 'string';
          break;
        case 'strings':
          invalidType = !Array.isArray(value) || value.some(x => typeof x !== 'string');
          break;
        case 'number':
          invalidType = typeof value !== 'number';
          break;
        case 'boolean':
          invalidType = typeof value !== 'boolean';
          break;
        case 'variable':
          invalidType = !(typeof value === 'string' || Array.isArray(value) && value.every(x => typeof x === 'string'));
          break;
      }

      if (invalidType || schema.values && !schema.values.includes(value)) {
        this.warning(`Ignoring attempt to set \`${name}\` to a invalid value of \`${value.toString()}\``);
      } else {
        store[schema.name] = value;
      }
    } else if (name.startsWith('$')) {
      // It's an environment variable
      store[name] = value;
    } else {
      this.warning(`Ignoring attempt to set unknown option \`${name}\` to a value of \`${value.toString()}\``);
    }
  }

  checkForKill() {
    if (this.state.killToken && this.state.killToken.error) throw this.state.killToken.error;
  }

  get ruleClasses() {
    return this.state.ruleClasses;
  }

  get filePath() {
    return this.state.filePath;
  }

  get rootPath() {
    return this.state.rootPath;
  }

  get files() {
    return this.state.files.values();
  }

  get rules() {
    return this.state.rules.values();
  }

  get targets() {
    const targets = new _set2.default();

    for (const rule of this.rules) {
      for (const file of rule.outputs) {
        const ext = _path2.default.extname(file.filePath);
        if (ext === `.${this.options.outputFormat}` || ext === '.xdv' && this.options.outputFormat === 'dvi') {
          targets.add(file.filePath);
        }
      }
    }

    return (0, _from2.default)(targets.values());
  }

  getTargetPaths() {
    return this.state.getTargetPaths();
  }

  getTargetFiles() {
    return this.state.getTargetFiles();
  }

  addRule(rule) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this2.state.addRule(rule);
    })();
  }

  normalizePath(filePath) {
    return this.state.normalizePath(filePath);
  }

  resolvePath(filePath) {
    return _path2.default.normalize(this.expandVariables(filePath));
  }

  expandVariables(value, additionalProperties = {}) {
    const properties = (0, _assign2.default)({}, this.state.env, this.env, additionalProperties);

    return value.replace(VARIABLE_PATTERN, (match, name) => properties[name] || match[0]);
  }

  globPath(pattern, { types = 'all', ignorePattern } = {}) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      try {
        return yield (0, _fastGlob2.default)(_this3.expandVariables(pattern), {
          cwd: _this3.rootPath,
          bashNative: [],
          onlyFiles: types === 'files',
          onlyDirs: types === 'directories',
          ignore: ignorePattern
        });
      } catch (error) {}

      return [];
    })();
  }

  getFile(filePath) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const file = yield _this4.state.getFile(filePath);
      if (file && _this4.options.jobName) file.jobNames.add(_this4.options.jobName);
      return file;
    })();
  }

  getFiles(filePaths) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];
      for (const filePath of filePaths) {
        const file = yield _this5.getFile(filePath);
        if (file) files.push(file);
      }
      return files;
    })();
  }

  getGlobbedFiles(pattern) {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];
      for (const filePath of yield _this6.globPath(pattern)) {
        const file = yield _this6.getFile(filePath);
        if (file) files.push(file);
      }
      return files;
    })();
  }

  error(text, name = 'DiCy') {
    this.log({ severity: 'error', name, text });
  }

  warning(text, name = 'DiCy') {
    this.log({ severity: 'warning', name, text });
  }

  info(text, name = 'DiCy') {
    this.log({ severity: 'info', name, text });
  }

  log(message) {
    const severity = this.options.severity || 'warning';
    if (severity === 'warning' && message.severity === 'info' || severity === 'error' && message.severity !== 'error') return;
    this.emit('log', (0, _extends3.default)({ type: 'log' }, message));
  }

  get components() {
    return this.state.components;
  }

  addNode(x) {
    this.state.addNode(x);
  }

  removeNode(x) {
    this.state.addNode(x);
  }

  hasEdge(x, y) {
    return this.state.hasEdge(x, y);
  }

  addEdge(x, y) {
    this.state.addEdge(x, y);
  }

  removeEdge(x, y) {
    this.state.removeEdge(x, y);
  }

  isGrandparentOf(x, y) {
    return this.state.isGrandparentOf(x, y);
  }

  getResolvedFile(filePath) {
    var _this7 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this7.getFile(_this7.resolvePath(filePath));
    })();
  }

  // EventEmmitter proxy
  addListener(eventName, listener) {
    return this.state.addListener(eventName, listener);
  }

  emit(eventName, ...args) {
    return this.state.emit(eventName, ...args);
  }

  eventNames() {
    return this.state.eventNames();
  }

  getMaxListeners() {
    return this.state.eventNames();
  }

  listenerCount(eventName) {
    return this.state.listenerCount(eventName);
  }

  listeners(eventName) {
    return this.state.listeners(eventName);
  }

  on(eventName, listener) {
    return this.state.on(eventName, listener);
  }

  once(eventName, listener) {
    return this.state.once(eventName, listener);
  }

  prependListener(eventName, listener) {
    return this.state.prependListener(eventName, listener);
  }

  prependOnceListener(eventName, listener) {
    return this.state.prependOnceListener(eventName, listener);
  }

  removeAllListeners(eventName) {
    return this.state.removeAllListeners(eventName);
  }

  removeListener(eventName, listener) {
    return this.state.removeListener(eventName, listener);
  }

  setMaxListeners(n) {
    return this.state.setMaxListeners(n);
  }

  executeChildProcess(command, options) {
    return new _promise2.default((resolve, reject) => {
      let stdout;
      let stderr;
      let exited = false;
      const handleExit = error => {
        if (exited) return;
        exited = true;

        if (child.pid) this.state.processes.delete(child.pid);
        if (error) {
          reject(error);
        } else {
          resolve({ stdout, stderr });
        }
      };
      const child = _child_process2.default.spawn(command, options);

      if (child.pid) this.state.processes.add(child.pid);
      child.on('error', handleExit);
      child.on('close', (code, signal) => {
        let error;
        if (code !== 0 || signal !== null) {
          error = new Error(`Command failed: \`${command}\`\n${stderr || ''}`.trim());
          // $FlowIgnore
          error.code = code;
          // $FlowIgnore
          error.signal = signal;
        }
        handleExit(error);
      });
      if (child.stdout) {
        child.stdout.setEncoding('utf8');
        child.stdout.on('data', data => {
          stdout = `${stdout || ''}${data}`;
        });
      }
      if (child.stderr) {
        child.stderr.setEncoding('utf8');
        child.stderr.on('data', data => {
          stderr = `${stderr || ''}${data}`;
        });
      }
    });
  }

  killChildProcesses() {
    for (const pid of this.state.processes.values()) {
      (0, _treeKill2.default)(pid);
    }
    this.state.processes.clear();
  }

  isOutputOf(file, ruleId) {
    return this.state.isOutputOf(file, ruleId);
  }
}
exports.default = StateConsumer;