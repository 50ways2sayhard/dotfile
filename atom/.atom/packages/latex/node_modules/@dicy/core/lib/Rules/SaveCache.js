'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _File = require('../File');

var _File2 = _interopRequireDefault(_File);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

var _State = require('../State');

var _State2 = _interopRequireDefault(_State);

var _types = require('../types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SaveCache extends _Rule2.default {

  static isApplicable(state, command, phase, options, parameters = []) {
    return (0, _asyncToGenerator3.default)(function* () {
      // Only apply if saveCache is enabled
      return options.saveCache;
    })();
  }

  preEvaluate() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      // If all output files are virtual the don't bother saving.
      if ((0, _from2.default)(_this.rules).every(function (rule) {
        return rule.outputs.every(function (file) {
          return file.virtual;
        });
      })) {
        _this.actions.delete('run');
      }
    })();
  }

  run() {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const cacheFilePath = _this2.resolvePath('$ROOTDIR/$NAME-cache.yaml');
      const cache = {
        version: _types.CACHE_VERSION,
        filePath: _this2.filePath,
        options: _this2.state.options,
        files: {},
        rules: []

        // Loop through all the files and add them to the cache.
      };for (const file of _this2.files) {
        // $FlowIgnore
        const fileCache = {
          timeStamp: file.timeStamp,
          jobNames: (0, _from2.default)(file.jobNames.values())
        };

        if (file.value) {
          fileCache.value = file.value;
        }

        if (file.hash) {
          fileCache.hash = file.hash;
        }

        if (file.type) {
          fileCache.type = file.type;
        }

        if (file.subType) {
          fileCache.subType = file.subType;
        }

        cache.files[file.filePath] = fileCache;
      }

      // Loop through all the rules and add them to the cache.
      for (const rule of _this2.rules) {
        const ruleCache = {
          name: rule.constructor.name,
          command: rule.command,
          phase: rule.phase,
          parameters: rule.parameters.map(function (file) {
            return file.filePath;
          }),
          inputs: rule.inputs.map(function (file) {
            return file.filePath;
          }),
          outputs: rule.outputs.map(function (file) {
            return file.filePath;
          })
        };

        if (rule.options.jobName) {
          ruleCache.jobName = rule.options.jobName;
        }

        cache.rules.push(ruleCache);
      }

      // Save the cache and update the timestamp.
      yield _File2.default.writeYaml(cacheFilePath, cache);
      _this2.state.cacheTimeStamp = yield _File2.default.getModifiedTime(cacheFilePath);

      return true;
    })();
  }
}
exports.default = SaveCache;
SaveCache.commands = new _set2.default(['save']);
SaveCache.alwaysEvaluate = true;
SaveCache.ignoreJobName = true;
SaveCache.description = 'Saves file and rule status to a cache (-cache.yaml) to assist with rebuilding.';