'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _File = require('../File');

var _File2 = _interopRequireDefault(_File);

var _Log = require('../Log');

var _Log2 = _interopRequireDefault(_Log);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

var _State = require('../State');

var _State2 = _interopRequireDefault(_State);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SplitIndex extends _Rule2.default {

  static isApplicable(state, command, phase, options, parameters = []) {
    return (0, _asyncToGenerator3.default)(function* () {
      const parsedLog = parameters[1].value;
      const base = _path2.default.basename(parameters[0].filePath);
      const messagePattern = new RegExp(`(Using splitted index at ${base}|Remember to run \\(pdf\\)latex again after calling \`splitindex')`);
      const wasGeneratedBySplitIndex = state.isOutputOf(parameters[0], 'SplitIndex');
      const splitindexCall = !!parsedLog && !!_Log2.default.findCall(parsedLog, 'splitindex', base);
      const splitindexMessage = !!parsedLog && !!_Log2.default.findMessage(parsedLog, messagePattern);

      // Only apply to index control files when there is some indication from the
      // log that we need to.
      return !wasGeneratedBySplitIndex && (splitindexCall || splitindexMessage);
    })();
  }

  getFileActions(file) {
    return (0, _asyncToGenerator3.default)(function* () {
      // Only return a run action for the actual idx file and updateDependencies
      // for the parsed splitindex output.
      switch (file.type) {
        case 'ParsedSplitIndexStdOut':
          return ['updateDependencies'];
        case 'ParsedLaTeXLog':
          return [];
        default:
          return ['run'];
      }
    })();
  }

  preEvaluate() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!_this.actions.has('run')) return;

      const parsedLog = _this.secondParameter.value;
      const { base } = _path2.default.parse(_this.firstParameter.filePath);

      // If the correct makeindex call is found in the log then delete the run
      // action.
      if (parsedLog) {
        const call = _Log2.default.findCall(parsedLog, 'splitindex', base, 'executed');
        if (call) {
          _this.info('Skipping splitindex call since splitindex was already executed via shell escape.');
          for (const call of _Log2.default.filterCalls(parsedLog, 'makeindex')) {
            yield _this.getOutputs(call.args.slice(1));
          }

          _this.actions.delete('run');
        }
      }
    })();
  }

  constructCommand() {
    // Be extra verbose and capture all output for parsing
    return {
      args: ['splitindex', '-v', '-v', '-m', '', '{{$FILEPATH_0}}'],
      cd: '$ROOTDIR',
      severity: 'error',
      inputs: ['$DIR_0/$NAME_0.log-ParsedSplitIndexStdOut'],
      stdout: '$DIR_0/$NAME_0.log-SplitIndexStdOut',
      stderr: '$DIR_0/$NAME_0.log-SplitIndexStdErr'
    };
  }
}
exports.default = SplitIndex;
SplitIndex.parameterTypes = [new _set2.default(['IndexControlFile']), new _set2.default(['ParsedLaTeXLog'])];
SplitIndex.description = 'Runs splitindex on any index files.';