'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _File = require('../File');

var _File2 = _interopRequireDefault(_File);

var _Log = require('../Log');

var _Log2 = _interopRequireDefault(_Log);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

var _State = require('../State');

var _State2 = _interopRequireDefault(_State);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class EpsToPdf extends _Rule2.default {

  static isApplicable(state, command, phase, options, parameters = []) {
    return (0, _asyncToGenerator3.default)(function* () {
      switch (parameters[1].type) {
        case 'Nil':
          // If there is not a LaTeX log present then only apply epstopdf when the
          // main source file is an EPS.
          return parameters[0].filePath === _path2.default.normalize(options.filePath) && options.outputFormat === 'pdf';
        case 'ParsedLaTeXLog':
          // When there is a LaTeX log present only apply epstopdf if there are
          // specific calls present, usually from the epstopdf package.
          return !!EpsToPdf.findCall(parameters[1].value, parameters[0].filePath);
        default:
          return false;
      }
    })();
  }

  /**
   * Find an epstopdf call either in the call list or in an epstopdf package
   * message.
   * @param  {ParsedLog}  parsedLog   The parsed LaTeX log.
   * @param  {string}     filePath    The file path to look for.
   * @return {ShellCall}              The shell call found or null if no
   *                                  matching call was found.
   */
  static findCall(parsedLog, filePath) {
    let call;

    if (parsedLog) {
      // First look for shell escape call.
      call = _Log2.default.findCall(parsedLog, /^r?epstopdf$/, filePath);

      if (!call) {
        // If there is no shell escape call then look for a message from the
        // epstopdf package.
        call = _Log2.default.findMessageMatches(parsedLog, /Command: <([^>]*)>/, 'Package epstopdf').map(match => _Log2.default.parseCall(match[1])).find(call => call.args.includes(filePath));
      }
    }

    return call;
  }

  initialize() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (_this.secondParameter.type === 'Nil') {
        _this.addResolvedTarget('$DIR_0/$NAME_0.pdf');
      } else {
        const call = EpsToPdf.findCall(_this.parameters[1].value, _this.parameters[0].filePath);

        if (call) {
          // There is a matching call so scrape the options from it.
          if (call.options.outfile) {
            _this.options.epstopdfOutputPath = call.options.outfile;
          } else if (call.args.length > 2) {
            _this.options.epstopdfOutputPath = call.args[2];
          }

          _this.options.epstopdfBoundingBox = call.options.exact ? 'exact' : call.options.hires ? 'hires' : 'default';

          _this.options.epstopdfRestricted = !!call.options.restricted;
        }
      }
    })();
  }

  getFileActions(file) {
    return (0, _asyncToGenerator3.default)(function* () {
      // Only return a run action for the actual eps file.
      return file.type === 'EncapsulatedPostScript' ? ['run'] : [];
    })();
  }

  preEvaluate() {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const call = EpsToPdf.findCall(_this2.parameters[1].value, _this2.parameters[0].filePath);

      if (call && call.status.startsWith('executed')) {
        // There is a matching and successful call so just get the resolved output
        // and skip the evaluation.
        _this2.info(`Skipping epstopdf call since epstopdf was already executed via shell escape.`);

        yield _this2.getResolvedOutput(_this2.options.epstopdfOutputPath);

        _this2.actions.delete('run');
      }
    })();
  }

  constructCommand() {
    const outputPath = this.options.epstopdfOutputPath;
    // Newer versions of epstopdf support the dvipdfm style "epstopdf in out"
    // but for backward compatability we use `--outfile` instead.
    const args = ['epstopdf', `--outfile={{${outputPath}}}`];

    // Look for a bounding box setting.
    switch (this.options.epstopdfBoundingBox) {
      case 'exact':
        args.push('--exact');
        break;
      case 'hires':
        args.push('--hires');
        break;
    }

    // Use restricted if required even though we are executing outside the
    // context of shell escape.
    if (this.options.epstopdfRestricted) {
      args.push('--restricted');
    }

    args.push('{{$FILEPATH_0}}');

    return {
      args,
      cd: '$ROOTDIR',
      severity: 'error',
      outputs: [outputPath]
    };
  }
}
exports.default = EpsToPdf;
EpsToPdf.parameterTypes = [new _set2.default(['EncapsulatedPostScript']), new _set2.default(['ParsedLaTeXLog', 'Nil'])];
EpsToPdf.description = 'Converts EPS to PDF using epstopdf.';