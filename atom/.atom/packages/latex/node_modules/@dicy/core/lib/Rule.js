'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _commandJoin = require('command-join');

var _commandJoin2 = _interopRequireDefault(_commandJoin);

var _State = require('./State');

var _State2 = _interopRequireDefault(_State);

var _File = require('./File');

var _File2 = _interopRequireDefault(_File);

var _StateConsumer = require('./StateConsumer');

var _StateConsumer2 = _interopRequireDefault(_StateConsumer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Rule extends _StateConsumer2.default {

  static analyzePhase(state, command, phase, options) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const appliesToPhase = _this.commands.has(command) && _this.phases.has(phase) && _this.parameterTypes.length === 0;

      if (appliesToPhase && (yield _this.isApplicable(state, command, phase, options))) {
        const rule = new _this(state, command, phase, options);
        yield rule.initialize();
        if (_this.alwaysEvaluate) rule.addActions();
        return rule;
      }
    })();
  }

  static analyzeFile(state, command, phase, options, file) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const rules = [];
      const appliesToFile = _this2.commands.has(command) && _this2.phases.has(phase) && _this2.parameterTypes.some(function (types) {
        return file && file.inTypeSet(types);
      });

      if (appliesToFile) {
        const files = (0, _from2.default)(state.files.values()).filter(function (file) {
          return !options.jobName || file.jobNames.has(options.jobName);
        });

        for (let i = 0; i < _this2.parameterTypes.length; i++) {
          if (file.inTypeSet(_this2.parameterTypes[i])) {
            const candidates = _this2.parameterTypes.map(function (types, index) {
              return index === i ? [file] : files.filter(function (file) {
                return file.inTypeSet(types);
              });
            });
            let indicies = candidates.map(function (files) {
              return files.length - 1;
            });

            while (indicies.every(function (index) {
              return index > -1;
            })) {
              const parameters = candidates.map(function (files, index) {
                return files[indicies[index]];
              });
              // $FlowIgnore
              const ruleId = state.getRuleId(_this2.name, command, phase, options.jobName, parameters.map(function (file) {
                return file.filePath;
              }));

              if (!state.rules.has(ruleId) && (yield _this2.isApplicable(state, command, phase, options, parameters))) {
                const rule = new _this2(state, command, phase, options, parameters);
                yield rule.initialize();
                if (_this2.alwaysEvaluate) rule.addActions(file);
                rules.push(rule);
              }

              let j = 0;
              while (j < indicies.length && --indicies[j] < 0) {
                indicies[j] = candidates[j].length - 1;
                j++;
              }

              if (j === indicies.length) break;
            }
          }
        }
      }

      return rules;
    })();
  }

  static isApplicable(state, command, phase, options, parameters = []) {
    return (0, _asyncToGenerator3.default)(function* () {
      return true;
    })();
  }

  constructor(state, command, phase, options, parameters = []) {
    super(state, options);

    this.parameters = [];
    this.actions = new _map2.default();
    this.failures = new _set2.default();
    this.parameters = parameters;
    this.command = command;
    this.phase = phase;
    this.id = state.getRuleId(this.constructor.name, command, phase, options.jobName, parameters.map(file => file.filePath));

    this.parameters.forEach((file, index) => {
      const { dir, base, name, ext } = _path2.default.parse(file.filePath);
      const rootPath = _path2.default.dirname(file.realFilePath);

      this.env[`FILEPATH_${index}`] = file.filePath;
      this.env[`ROOTDIR_${index}`] = rootPath;
      this.env[`DIR_${index}`] = dir || '.';
      this.env[`BASE_${index}`] = base;
      this.env[`NAME_${index}`] = name;
      this.env[`EXT_${index}`] = ext;

      if (options.jobName) file.jobNames.add(options.jobName);
      state.addEdge(file.filePath, this.id);
    });
  }

  error(text, name) {
    super.error(text, name || this.id);
  }

  warning(text, name) {
    super.warning(text, name || this.id);
  }

  info(text, name) {
    super.info(text, name || this.id);
  }

  initialize() {
    return (0, _asyncToGenerator3.default)(function* () {})();
  }

  phaseInitialize(command, phase) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if ((!command || command === _this3.command) && (!phase || phase === _this3.phase) && _this3.constructor.alwaysEvaluate) {
        if (_this3.inputs.size === 0) {
          _this3.addActions();
        } else {
          for (const input of _this3.inputs) {
            _this3.addActions(input, (yield _this3.getFileActions(input)));
          }
        }
      }
    })();
  }

  addFileActions(file, command, phase) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if ((!command || command === _this4.command) && (!phase || phase === _this4.phase) && file.hasBeenUpdated) {
        const timeStamp = _this4.timeStamp;
        const ruleNeedsUpdate = !timeStamp || timeStamp < file.timeStamp;
        for (const action of yield _this4.getFileActions(file)) {
          if (ruleNeedsUpdate) _this4.failures.delete(action);
          if (action === 'updateDependencies' || ruleNeedsUpdate) {
            _this4.addActions(file, [action]);
          }
        }
      }
    })();
  }

  getFileActions(file) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this5.constructor.defaultActions;
    })();
  }

  addActions(file, actions) {
    if (!actions) actions = this.constructor.defaultActions;

    for (const action of actions) {
      const files = this.actions.get(action);
      if (!files) {
        this.actions.set(action, new _set2.default(file ? [file] : []));
      } else if (file) {
        files.add(file);
      }
    }
  }

  get firstParameter() {
    return this.parameters[0];
  }

  get secondParameter() {
    return this.parameters[1];
  }

  get thirdParameter() {
    return this.parameters[2];
  }

  get needsEvaluation() {
    return this.actions.size !== 0;
  }

  get timeStamp() {
    return this.outputs.reduce((c, t) => !c || t.timeStamp > c ? t.timeStamp : c, null);
  }

  get inputs() {
    const predecessors = this.state.graph.predecessors(this.id) || [];
    // $FlowIgnore
    return predecessors.map(filePath => this.state.files.get(filePath)).filter(file => file);
  }

  get outputs() {
    const successors = this.state.graph.successors(this.id) || [];
    // $FlowIgnore
    return successors.map(filePath => this.state.files.get(filePath)).filter(file => file);
  }

  preEvaluate() {
    return (0, _asyncToGenerator3.default)(function* () {})();
  }

  evaluate(action) {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      try {
        let success = true;

        yield _this6.preEvaluate();
        if (!_this6.actions.has(action)) return true;
        _this6.actionTrace(action);

        switch (action) {
          case 'parse':
            success = yield _this6.parse();
            break;
          case 'updateDependencies':
            success = yield _this6.updateDependencies();
            break;
          default:
            success = yield _this6.run();
            break;
        }

        if (success) {
          _this6.failures.delete(action);
        } else {
          _this6.failures.add(action);
        }
        _this6.actions.delete(action);
        yield _this6.updateOutputs();

        return success;
      } catch (error) {
        _this6.error(error.stack);
      }

      return false;
    })();
  }

  updateDependencies() {
    var _this7 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = _this7.actions.get('updateDependencies');

      if (files) {
        for (const file of files.values()) {
          const parsedLog = file.value;

          if (parsedLog) {
            if (parsedLog.inputs) yield _this7.getInputs(parsedLog.inputs);
            if (parsedLog.outputs) yield _this7.getOutputs(parsedLog.outputs);
          }
        }
      }

      return true;
    })();
  }

  resolveAllPaths(value) {
    return value.replace(/\{\{(.*?)\}\}/, (match, filePath) => this.resolvePath(filePath));
  }

  executeCommand(commandOptions) {
    var _this8 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      try {
        // We only capture stdout and stderr if explicitly instructed to. This is
        // possibly to conserve some memory, but mostly it is a work around for a
        // bug in CLISP <https://sourceforge.net/p/clisp/bugs/378/> which makes it
        // impossible to run xindy without pseudo terminal support.
        const options = _this8.constructProcessOptions(commandOptions.cd, false, !!commandOptions.stdout, !!commandOptions.stderr);
        // Use ampersand as a filler for empty arguments. This is to work around
        // a bug in command-join.
        const command = (0, _commandJoin2.default)(commandOptions.args.map(function (arg) {
          return _this8.resolveAllPaths(arg) || '&';
        })).replace(/(['"])\^?&(['"])/g, '$1$2');

        _this8.emit('command', {
          type: 'command',
          rule: _this8.id,
          command
        });

        const result = yield _this8.executeChildProcess(command, options);

        if (commandOptions.inputs) yield _this8.getResolvedInputs(commandOptions.inputs);

        if (commandOptions.outputs) yield _this8.getResolvedOutputs(commandOptions.outputs);

        if (commandOptions.globbedInputs) {
          yield _promise2.default.all(commandOptions.globbedInputs.map(function (pattern) {
            return _this8.getGlobbedInputs(pattern);
          }));
        }

        if (commandOptions.globbedOutputs) {
          yield _promise2.default.all(commandOptions.globbedOutputs.map(function (pattern) {
            return _this8.getGlobbedOutputs(pattern);
          }));
        }

        if (typeof commandOptions.stdout === 'string') {
          const output = yield _this8.getResolvedOutput(commandOptions.stdout);
          if (output) output.value = result.stdout;
        }

        if (typeof commandOptions.stderr === 'string') {
          const output = yield _this8.getResolvedOutput(commandOptions.stderr);
          if (output) output.value = result.stderr;
        }

        return result;
      } catch (error) {
        _this8.log({ severity: commandOptions.severity, text: error.toString(), name: _this8.constructor.name });
        throw error;
      }
    })();
  }

  run() {
    var _this9 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      try {
        const commandOptions = _this9.constructCommand();

        yield _this9.executeCommand(commandOptions);

        return true;
      } catch (error) {
        return false;
      }
    })();
  }

  parse() {
    return (0, _asyncToGenerator3.default)(function* () {
      return true;
    })();
  }

  getOutput(filePath) {
    var _this10 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let file = yield _this10.getFile(filePath);

      if (file && !_this10.hasEdge(_this10.id, file.filePath)) {
        _this10.addEdge(_this10.id, file.filePath);
        _this10.emit('outputAdded', {
          type: 'outputAdded',
          rule: _this10.id,
          file: file.filePath,
          virtual: file.virtual
        });
      }

      return file;
    })();
  }

  getOutputs(filePaths) {
    var _this11 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];

      for (const filePath of filePaths) {
        const file = yield _this11.getOutput(filePath);
        if (file) files.push(file);
      }

      return files;
    })();
  }

  updateOutputs() {
    var _this12 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      for (const file of _this12.outputs) {
        if (yield file.update()) {
          _this12.emit('fileChanged', {
            type: 'fileChanged',
            file,
            virtual: file.virtual
          });
        }
      }
    })();
  }

  getInput(filePath) {
    var _this13 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let file = yield _this13.getFile(filePath);

      if (file && !_this13.hasEdge(file.filePath, _this13.id)) {
        _this13.addEdge(file.filePath, _this13.id);
        _this13.emit('inputAdded', {
          type: 'inputAdded',
          rule: _this13.id,
          file: file.filePath,
          virtual: file.virtual
        });
      }

      return file;
    })();
  }

  getInputs(filePaths) {
    var _this14 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];

      for (const filePath of filePaths) {
        const file = yield _this14.getInput(filePath);
        if (file) files.push(file);
      }

      return files;
    })();
  }

  removeFile(file) {
    var _this15 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this15.state.removeEdge(_this15.id, file.filePath);
      _this15.state.removeEdge(file.filePath, _this15.id);

      return _this15.parameters.includes(file);
    })();
  }

  getResolvedInput(filePath) {
    var _this16 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const expanded = _this16.resolvePath(filePath);
      return _this16.getInput(expanded);
    })();
  }

  getResolvedInputs(filePaths) {
    var _this17 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];

      for (const filePath of filePaths) {
        const file = yield _this17.getResolvedInput(filePath);
        if (file) files.push(file);
      }

      return files;
    })();
  }

  getResolvedOutput(filePath) {
    var _this18 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const expanded = _this18.resolvePath(filePath);
      return _this18.getOutput(expanded);
    })();
  }

  getResolvedOutputs(filePaths) {
    var _this19 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];

      for (const filePath of filePaths) {
        const file = yield _this19.getResolvedOutput(filePath);
        if (file) files.push(file);
      }

      return files;
    })();
  }

  getGlobbedInputs(pattern) {
    var _this20 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];
      for (const filePath of yield _this20.globPath(pattern)) {
        const file = yield _this20.getInput(filePath);
        if (file) files.push(file);
      }
      return files;
    })();
  }

  getGlobbedOutputs(pattern) {
    var _this21 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];
      for (const filePath of yield _this21.globPath(pattern)) {
        const file = yield _this21.getOutput(filePath);
        if (file) files.push(file);
      }
      return files;
    })();
  }

  constructProcessOptions(cd, stdin, stdout, stderr) {
    const processOptions = {
      cwd: this.resolvePath(cd),
      env: (0, _assign2.default)({}, process.env),
      shell: true,
      stdio: [stdin ? 'pipe' : 'ignore', stdout ? 'pipe' : 'ignore', stderr ? 'pipe' : 'ignore']
    };

    for (const name in this.options) {
      if (!name.startsWith('$')) continue;
      const value = this.options[name];
      const envName = process.platform === 'win32' && name === '$PATH' ? 'Path' : name.substring(1);
      if (Array.isArray(value)) {
        const emptyPath = name === '$PATH' ? process.env[envName] || '' : '';
        const paths = value.map(filePath => filePath ? this.resolvePath(filePath.toString()) : emptyPath);

        if (processOptions.env[envName] && paths.length > 0 && paths[paths.length - 1] === '') {
          paths[paths.length - 1] = processOptions.env[envName];
        }

        processOptions.env[envName] = paths.join(_path2.default.delimiter);
      } else if (typeof value === 'string') {
        processOptions.env[envName] = this.expandVariables(value);
      } else {
        processOptions.env[envName] = value.toString();
      }
    }

    return processOptions;
  }

  constructCommand() {
    return { args: [], cd: '$ROOTDIR', severity: 'error' };
  }

  actionTrace(action) {
    const files = this.actions.get(action);
    this.emit('action', {
      type: 'action',
      action,
      rule: this.id,
      triggers: files ? (0, _from2.default)(files).map(file => file.filePath) : []
    });
  }
}
exports.default = Rule;
Rule.parameterTypes = [];
Rule.phases = new _set2.default(['execute']);
Rule.commands = new _set2.default(['build']);
Rule.alwaysEvaluate = false;
Rule.ignoreJobName = false;
Rule.defaultActions = ['run'];
Rule.description = '';