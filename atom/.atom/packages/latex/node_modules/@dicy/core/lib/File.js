'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _commandJoin = require('command-join');

var _commandJoin2 = _interopRequireDefault(_commandJoin);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readline = require('readline');

var _readline2 = _interopRequireDefault(_readline);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class File {

  /**
   * Construct a new File. Because creating a file required asynchronous file
   * system access this method is used only to initialize the File instance. Used
   * the `create` method to actual create an instance.
   * @param  {string} realFilePath The actual file system path.
   * @param  {string} filePath     The file path relative to the project root.
   * @param  {Date}   timeStamp    The time of the last update provided by cache.
   * @param  {string} hash         The last content hash provided by cache.
   * @param  {any}    value        The value of the virtual file.
   */

  // Has the file been changed during the current run?

  // Has the file been analyzed in the current cycle?

  // A hash of the file contents. Used to verify that file has actually changed
  // when the timestamp changes

  // Last update time of the file.

  // The main type of the file, i.e. LaTeX, BibTeX, ...


  // The complete and real file path in the file system.
  constructor(realFilePath, filePath, timeStamp, hash, value) {
    this.virtual = false;
    this.jobNames = new _set2.default();
    this.analyzed = false;
    this._hasBeenUpdated = false;
    this.hasBeenUpdatedCache = false;

    this.realFilePath = realFilePath;
    this.filePath = filePath;
    if (timeStamp) this.timeStamp = timeStamp;
    if (hash) this.hash = hash;
    if (value) this._value = value;
  }

  /**
   * Create a new File.
   * @param  {string} realFilePath The actual file system path.
   * @param  {string} filePath     The file path relative to the project root.
   * @param  {Date}   timeStamp    The time of the last update provided by cache.
   * @param  {string} hash         The last content hash provided by cache.
   * @param  {any}    value        The value of the virtual file.
   * @return {File}                The File instance.
   */

  // The value of the virtual file.

  // Has the file been updated in the current cycle?

  // Job names currently associated with the file.

  // If it is a virtual or a physical file. Virtual files are usually in-memory
  // copies of parsed files such as log files.

  // An optional sub type. Usually the document class for LaTeX documents.

  // The file path relative to the project root.
  static create(realFilePath, filePath, timeStamp, hash, value) {
    return (0, _asyncToGenerator3.default)(function* () {
      const file = new File(realFilePath, filePath, timeStamp, hash, value);

      yield file.findType();
      // If the file type is not a virtual file type and there is no physical file
      // then just quit.
      if (!file.virtual && !(yield File.canRead(realFilePath))) return;
      // Check for an update to file in case it has changed since the cache was
      // finalized.
      yield file.update();

      return file;
    })();
  }

  /**
   * Parse the file using a list of Parsers.
   * @param  {Array<Parser>}      parsers   List of parsers to apply.
   * @param  {string => boolean}  isWrapped A function to test for line wrapping.
   */
  parse(parsers, isWrapped = line => false) {
    return new _promise2.default((resolve, reject) => {
      // The maximum number of lines that we need to maintain in a buffer to
      // satisfy all the parsers.
      const bufferSize = parsers.reduce((current, parser) => Math.max(current, parser.patterns.length), 0);
      // A type representing an unwrapped line where `count` is the number of
      // wrapped lines in the file that each unwrapped line represents.

      // The buffer of unwrapped lines.
      let lines = [];
      let lineNumber = 1;
      // A function to check form matches in all the parsers.
      const checkForMatches = (finalCheck = false) => {
        while (lines.length > 0) {
          // If this is not the final check then do not check if there is not
          // enough lines in the buffer to check all parsers.
          if (!finalCheck && lines.length < bufferSize) break;

          let matched = false;

          for (const parser of parsers) {
            // If there is not enough lines to check this parser then skip it.
            if (parser.patterns.length > lines.length) continue;

            const matches = parser.patterns.map((pattern, index) => lines[index].text.match(pattern));

            matched = matches.every(match => match);
            if (matched) {
              const groups = {
                // $FlowIgnore
                _: matches.map(match => match[0]).join('\n')
              };
              if (parser.names) {
                // $FlowIgnore
                const m = [].concat(...matches.map(match => match.slice(1)));
                const names = parser.names || [];
                names.map((name, index) => {
                  if (m[index] !== undefined) groups[name] = m[index];
                });
              } else {
                const m = [].concat(...matches);
                groups.captures = m;
              }
              const lineCount = lines.splice(0, parser.patterns.length).reduce((total, line) => total + line.count, 0);
              const reference = {
                file: this.filePath,
                range: {
                  start: lineNumber,
                  end: lineNumber + lineCount - 1
                }
              };
              lineNumber += lineCount;
              parser.evaluate(reference, groups);
              break;
            }
          }
          if (!matched) {
            // No match so pop the leading line from the queue.
            lineNumber += lines[0].count;
            lines.shift();
          }
        }
      };

      if (this.virtual) {
        const rawLines = this.value ? this.value.toString().split(/\r?\n/) : [];
        lines = rawLines.map(text => ({ text, count: 1 }));
        for (let index = lines.length - 1; index > -1; index--) {
          if (isWrapped(lines[index].text) && index + 1 < lines.length) {
            lines[index].text += lines[index + 1].text;
            lines[index].count += lines[index + 1].count;
            lines.splice(index + 1, 1);
          }
        }
        checkForMatches(true);
        resolve();
      } else {
        let current = { text: '', count: 0 };
        const rl = _readline2.default.createInterface({
          input: _fsExtra2.default.createReadStream(this.realFilePath, { encoding: 'utf-8' })
        });

        rl.on('line', line => {
          current.text += line;
          current.count += 1;
          if (!isWrapped(line)) {
            lines.push(current);
            current = { text: '', count: 0 };
            checkForMatches();
          }
        }).on('close', () => {
          checkForMatches(true);
          resolve();
        });
      }
    });
  }

  /**
   * Getter for `hasBeenUpdated`
   * @return {Boolean}  Update status.
   */
  get hasBeenUpdated() {
    return this._hasBeenUpdated;
  }

  /**
   * Setter for `hasBeenUpdated`
   * @param {Boolean}  value  Update status.
   */
  set hasBeenUpdated(value) {
    this._hasBeenUpdated = value;
    // Cache the update flag in case it gets reset in the cycle.
    this.hasBeenUpdatedCache = value || this.hasBeenUpdatedCache;
  }

  get value() {
    return this._value;
  }

  set value(value) {
    if (!_lodash2.default.isEqual(value, this._value)) {
      this.hasBeenUpdated = true;
      this.timeStamp = new Date();
    }
    this._value = value;
  }

  /**
   * Load the file types from the resource file `resources/file-types.yaml`
   */
  static loadFileTypes() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!_this.fileTypes) {
        const fileTypesPath = _path2.default.resolve(__dirname, '..', 'resources', 'file-types.yaml');
        const value = yield _this.readYaml(fileTypesPath);

        // Create a new map and iterate through each type in the file and save it
        // to the map.
        _this.fileTypes = new _map2.default();
        for (const name in value) {
          _this.fileTypes.set(name, value[name]);
        }
      }
    })();
  }

  /**
   * Find the type of a file by iterating through the available types and
   * testing each one.
   * @return {void}
   */
  findType() {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      // Make sure the file types are loaded
      yield File.loadFileTypes();

      // Go through each file type and test each one. Break when we find a match.
      for (const [type, properties] of File.fileTypes.entries()) {
        if (yield _this2.isFileType(type, properties)) break;
      }
    })();
  }

  /**
   * Test a file to see if it matches the supplied FileType.
   * @param  {String}   name     The name of the file type
   * @param  {FileType} fileType The FileType descriptor
   * @return {Boolean}           True if the file matches the file type, false
   *                             otherwise.
   */
  isFileType(name, fileType) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      // If the file type descriptor does not have a pattern for the file name or
      // a pattern for the contents of the file then it must be a virtual file.
      if (!fileType.fileName && !fileType.contents) {
        // Test to see if the file path ends in the file type's name.
        const isMatch = _this3.realFilePath.endsWith(`-${name}`);
        if (isMatch) {
          // Its a match so set the file type.
          _this3.type = name;
          _this3.virtual = true;
        }
        return isMatch;
      }

      // If file name does not match required pattern then just quit.
      if (fileType.fileName && !fileType.fileName.test(_this3.realFilePath)) {
        return false;
      }

      // Does the file type descriptor require specific file contents pattern?
      if (fileType.contents) {
        // Make sure the file is readable.
        if (yield _this3.canRead()) {
          const contents = yield _this3.read();
          const [value, subType] = contents.match(fileType.contents || '') || [];

          if (value) {
            // We have a match so set the type and sub type.
            _this3.type = name;
            _this3.subType = subType;
            return true;
          }
        }
      } else {
        // No specific contents required so we have a successful match!
        _this3.type = name;
        return true;
      }

      return false;
    })();
  }

  inTypeSet(types) {
    return types.has('*') || types.has(this.type);
  }

  delete() {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!_this4.virtual) yield File.remove(_this4.realFilePath);
    })();
  }

  /**
   * Update the file time stamp
   * @return {boolean}  true if time stamp has been updated, false otherwise.
   */
  updateTimeStamp() {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      // If it is a virtual file then we only update the time stamp when `value`
      // is set.
      if (_this5.virtual) return false;

      // Save the old time stamp and get the current one.
      const oldTimeStamp = _this5.timeStamp;
      _this5.timeStamp = yield File.getModifiedTime(_this5.realFilePath);

      // Return true indicating an updated time stamp if there was no time stamp
      // before or the new time stamp is more recent.
      return !oldTimeStamp || oldTimeStamp < _this5.timeStamp;
    })();
  }

  updateHash() {
    const fileType = File.fileTypes.get(this.type);

    if (this.virtual || _path2.default.isAbsolute(this.filePath)) return _promise2.default.resolve(true);

    return new _promise2.default((resolve, reject) => {
      // const fileType = File.fileTypes.get(this.type)
      const hash = _crypto2.default.createHash('sha256');
      const finish = () => {
        const oldHash = this.hash;
        this.hash = hash.digest('base64');
        resolve(oldHash !== this.hash);
      };

      if (fileType && fileType.hashFilter) {
        const command = (0, _commandJoin2.default)([fileType.hashFilter, this.realFilePath]);
        _child_process2.default.exec(command, {}, (error, stdout, stderr) => {
          if (error) {
            resolve(true);
          } else {
            for (const line of stdout.toString().split(/\n/g)) {
              if (!fileType.hashSkip || !fileType.hashSkip.test(line)) hash.update(line);
            }
            finish();
          }
        });
      } else if (fileType && fileType.hashSkip) {
        const rl = _readline2.default.createInterface({
          input: _fsExtra2.default.createReadStream(this.realFilePath, { encoding: 'utf-8' })
        });

        rl.on('line', line => {
          if (!fileType.hashSkip || !fileType.hashSkip.test(line)) hash.update(line);
        }).on('close', finish);
      } else {
        _fsExtra2.default.createReadStream(this.realFilePath).on('data', data => hash.update(data)).on('end', finish);
      }
    });
  }

  update() {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const updated = (yield _this6.updateTimeStamp()) && (yield _this6.updateHash());
      _this6.hasBeenUpdated = _this6.hasBeenUpdated || updated;
    })();
  }

  static read(filePath) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.readFile(filePath, { encoding: 'utf-8' }, (error, data) => {
        if (error) {
          reject(error);
        } else {
          resolve(data);
        }
      });
    });
  }

  read() {
    return File.read(this.realFilePath);
  }

  static readYaml(filePath, fullSchema = true) {
    return (0, _asyncToGenerator3.default)(function* () {
      const contents = yield File.read(filePath);
      return _jsYaml2.default.load(contents, {
        schema: fullSchema ? _jsYaml2.default.DEFAULT_FULL_SCHEMA : _jsYaml2.default.DEFAULT_SAFE_SCHEMA
      });
    })();
  }

  readYaml() {
    return File.readYaml(this.realFilePath);
  }

  static write(filePath, value) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.writeFile(filePath, value, { encoding: 'utf-8' }, error => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }

  write(value) {
    return File.write(this.realFilePath, value);
  }

  static writeYaml(filePath, value, fullSchema = false) {
    return (0, _asyncToGenerator3.default)(function* () {
      const contents = _jsYaml2.default.dump(value, {
        skipInvalid: true,
        schema: fullSchema ? _jsYaml2.default.DEFAULT_FULL_SCHEMA : _jsYaml2.default.DEFAULT_SAFE_SCHEMA
      });
      yield _fsExtra2.default.writeFile(filePath, contents);
    })();
  }

  static canRead(filePath) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.access(filePath, _fsExtra2.default.constants.R_OK, error => resolve(!error));
    });
  }

  canRead() {
    return File.canRead(this.realFilePath);
  }

  static getModifiedTime(filePath) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.stat(filePath, (error, stat) => resolve(error ? new Date() : stat.mtime));
    });
  }

  static isFile(filePath) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.stat(filePath, (error, stat) => resolve(!error && stat.isFile()));
    });
  }

  static isDirectory(filePath) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.stat(filePath, (error, stat) => resolve(!error && stat.isDirectory()));
    });
  }

  static remove(filePath) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.remove(filePath, error => error ? reject(error) : resolve());
    });
  }

  static ensureDir(filePath) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.ensureDir(filePath, error => error ? reject(error) : resolve());
    });
  }

  static copy(from, to) {
    return new _promise2.default((resolve, reject) => {
      _fsExtra2.default.copy(from, to, error => error ? reject(error) : resolve());
    });
  }

  copy(to) {
    return File.copy(this.realFilePath, to);
  }
}
exports.default = File;