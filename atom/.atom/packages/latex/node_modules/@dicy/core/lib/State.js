'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getOwnPropertyNames = require('babel-runtime/core-js/object/get-own-property-names');

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _graphlib = require('graphlib');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _File = require('./File');

var _File2 = _interopRequireDefault(_File);

var _Rule = require('./Rule');

var _Rule2 = _interopRequireDefault(_Rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getLabel(x) {
  return x instanceof _File2.default ? x.filePath : x.id;
}

// import _ from 'lodash'
class State extends _events2.default {
  // distances: Map<string, number> = new Map()
  constructor(filePath, schema = []) {
    super();
    this.files = new _map2.default();
    this.rules = new _map2.default();
    this.options = {};
    this.defaultOptions = {};
    this.optionSchema = new _map2.default();
    this.graphProperties = {};
    this.ruleClasses = [];
    this.processes = new _set2.default();
    this.targets = new _set2.default();
    this.graph = new _graphlib.Graph();
    this.optionProxies = {};
    const resolveFilePath = _path2.default.resolve(filePath);
    const { dir, base, name, ext } = _path2.default.parse(resolveFilePath);
    this.filePath = base;
    this.rootPath = dir;
    for (const option of schema) {
      this.optionSchema.set(option.name, option);
      for (const alias of option.aliases || []) {
        this.optionSchema.set(alias, option);
      }
      if (option.defaultValue) this.defaultOptions[option.name] = option.defaultValue;
    }
    this.assignOptions(this.defaultOptions);

    this.env = (0, _assign2.default)({}, process.env, {
      FILEPATH: base,
      ROOTDIR: dir,
      DIR: '.',
      BASE: base,
      NAME: name,
      EXT: ext
    });
    if (process.platform === 'win32') {
      (0, _assign2.default)(this.env, {
        HOME: process.env.USERPROFILE,
        PATH: process.env.Path
      });
    }
  }

  getTargetPaths(absolute = false) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const results = [];
      for (const target of _this.targets.values()) {
        const file = yield _this.getFile(target);
        if (file) results.push(absolute ? file.realFilePath : target);
      }
      return results;
    })();
  }

  getTargetFiles() {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const results = [];
      for (const target of _this2.targets.values()) {
        const file = yield _this2.getFile(target);
        if (file) results.push(file);
      }
      return results;
    })();
  }

  removeTarget(filePath) {
    this.targets.delete(filePath);
  }

  normalizePath(filePath) {
    filePath = _path2.default.normalize(filePath);

    if (_path2.default.isAbsolute(filePath)) {
      const dirPaths = [this.rootPath];

      for (const dir of dirPaths) {
        const candidateFilePath = _path2.default.relative(dir, filePath);
        if (!candidateFilePath.startsWith('..')) {
          return candidateFilePath;
        }
      }
    }

    return filePath;
  }

  addRule(rule) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this3.rules.set(rule.id, rule);
      _this3.addNode(rule.id);
      rule.addActions();
    })();
  }

  removeRule(rule) {
    this.rules.delete(rule.id);
    this.removeNode(rule.id);
  }

  addCachedRule(cache) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const options = _this4.getJobOptions(cache.jobName);
      const id = _this4.getRuleId(cache.name, cache.command, cache.phase, cache.jobName, cache.parameters);
      if (_this4.rules.has(id)) return;

      const RuleClass = _this4.ruleClasses.find(function (ruleClass) {
        return ruleClass.name === cache.name;
      });
      if (RuleClass) {
        const parameters = [];
        for (const filePath of cache.parameters) {
          const parameter = yield _this4.getFile(filePath);
          if (!parameter) break;
          parameters.push(parameter);
        }
        // $FlowIgnore
        const rule = new RuleClass(_this4, cache.command, cache.phase, options, parameters);
        _this4.addNode(rule.id);
        yield rule.initialize();
        _this4.rules.set(rule.id, rule);
        yield rule.getInputs(cache.inputs);
        const outputs = yield rule.getOutputs(cache.outputs);
        if (rule.constructor.alwaysEvaluate || outputs.length !== cache.outputs.length) {
          // At least one of the outputs is missing or the rule should always run.
          rule.addActions();
        }
        for (const input of rule.inputs) {
          yield rule.addFileActions(input);
        }
      }
    })();
  }

  getRuleId(name, command, phase, jobName, parameters = []) {
    const items = [command, phase, jobName || ''].concat(parameters);
    return `${name}(${items.join(';')})`;
  }

  getRule(name, command, phase, jobName, parameters = []) {
    const id = this.getRuleId(name, command, phase, jobName, parameters);
    return this.rules.get(id);
  }

  addNode(x) {
    this.graph.setNode(x);
    this.graphProperties = {};
  }

  removeNode(x) {
    this.graph.removeNode(x);
    this.graphProperties = {};
  }

  hasEdge(x, y) {
    return this.graph.hasEdge(x, y);
  }

  addEdge(x, y) {
    this.graph.setEdge(x, y);
    this.graphProperties = {};
  }

  removeEdge(x, y) {
    this.graph.removeEdge(x, y);
    this.graphProperties = {};
  }

  getFile(filePath, { timeStamp, hash, value } = {}) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      filePath = _this5.normalizePath(filePath);
      let file = _this5.files.get(filePath);

      if (!file) {
        file = yield _File2.default.create(_path2.default.resolve(_this5.rootPath, filePath), filePath, timeStamp, hash, value);
        if (!file) {
          _this5.graph.removeNode(filePath);
          _this5.emit('fileRemoved', {
            type: 'fileRemoved',
            file: filePath
          });
          return;
        }
        _this5.addNode(filePath);
        _this5.emit('fileAdded', {
          type: 'fileAdded',
          file: filePath,
          virtual: file.virtual
        });
        _this5.files.set(filePath, file);
      }

      return file;
    })();
  }

  deleteFile(file, jobName, unlink = true) {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const invalidRules = [];

      for (const rule of _this6.rules.values()) {
        if (rule.jobName === jobName) {
          if (yield rule.removeFile(file)) {
            // This file is one of the parameters of the rule so we need to remove
            // the rule.
            invalidRules.push(rule);
          }
        }
      }

      for (const rule of invalidRules) {
        _this6.removeNode(rule.id);
      }

      if (jobName) file.jobNames.delete(jobName);
      if (file.jobNames.size === 0) {
        if (unlink) {
          yield file.delete();
          _this6.emit('fileDeleted', {
            type: 'fileDeleted',
            file: file.filePath,
            virtual: file.virtual
          });
        }
        _this6.removeNode(file.filePath);
        _this6.files.delete(file.filePath);
      }
    })();
  }

  assignSubOptions(to, from) {
    for (const name in from) {
      if (from.hasOwnProperty(name)) {
        const value = from[name];
        if (typeof value !== 'object' || Array.isArray(value)) {
          const schema = this.optionSchema.get(name);
          if (schema) {
            to[schema.name] = value;
          } else if (name.startsWith('$')) {
            // It's an environment variable
            to[name] = value;
          } else {
            // Tell somebody!
          }
        } else {
          if (!(name in to)) to[name] = {};
          this.assignSubOptions(to[name], value);
        }
      }
    }
  }

  assignOptions(options) {
    this.assignSubOptions(this.options, options);
  }

  resetOptions() {
    for (const name of (0, _getOwnPropertyNames2.default)(this.options)) {
      delete this.options[name];
    }

    this.assignOptions(this.defaultOptions);
  }

  getJobOptions(jobName = null) {
    let optionProxy = this.optionProxies[jobName];

    if (!optionProxy) {
      this.optionProxies[jobName] = optionProxy = new Proxy(this.options, {
        get: (target, name) => {
          if (name === 'jobNames') {
            if ('jobName' in target) return [target.jobName];
            if ('jobNames' in target) return target.jobNames;
            if ('jobs' in target) return (0, _keys2.default)(target.jobs);
            return [null];
          }

          if (jobName) {
            if (name === 'jobName') return jobName;
            if ('jobs' in target) {
              const jobOptions = target.jobs[jobName];
              if (jobOptions && name in jobOptions) return jobOptions[name];
            }
          }

          const schema = this.optionSchema.get(name);

          if (schema && schema.type === 'boolean') {
            return !!target[name];
          }

          return name === 'filePath' ? this.filePath : target[name];
        },
        ownKeys: target => {
          const keys = new _set2.default(['filePath', 'jobNames']);

          if (jobName && 'jobs' in target) {
            const jobOptions = target.jobs[jobName];
            if (jobOptions) (0, _keys2.default)(jobOptions).forEach(key => keys.add(key));
          }

          this.optionSchema.forEach(option => {
            if (option.type === 'boolean') keys.add(option.name);
          });

          (0, _keys2.default)(target).forEach(key => keys.add(key));

          keys.delete('jobs');

          return (0, _from2.default)(keys.values());
        }
      });
    }

    return optionProxy;
  }

  get components() {
    if (!this.graphProperties.components) {
      this.graphProperties.components = _graphlib.alg.components(this.graph).map(component => component.map(id => this.rules.get(id)).filter(rule => rule)).filter(component => component.length > 0);
    }

    return this.graphProperties.components;
  }

  isGrandparentOf(x, y) {
    const xLabel = getLabel(x);
    const yLabel = getLabel(y);

    return this.graph.predecessors(yLabel).some(file => this.graph.predecessors(file).some(r => r === xLabel));
  }

  getInputRules(file) {
    const successors = this.graph.successors(file.filePath) || [];
    // $FlowIgnore
    return successors.map(id => this.rules.get(id)).filter(rule => rule);
  }

  getOutputRules(file) {
    const predecessors = this.graph.predecessors(file.filePath) || [];
    // $FlowIgnore
    return predecessors.map(id => this.rules.get(id)).filter(rule => rule);
  }

  isOutputOf(file, ruleId) {
    return this.graph.inEdges(file.filePath).some(edge => edge.v.startsWith(ruleId));
  }
}
exports.default = State;