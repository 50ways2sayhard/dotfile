'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _fastGlob = require('fast-glob');

var _fastGlob2 = _interopRequireDefault(_fastGlob);

var _micromatch = require('micromatch');

var _micromatch2 = _interopRequireDefault(_micromatch);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readdirEnhanced = require('readdir-enhanced');

var _readdirEnhanced2 = _interopRequireDefault(_readdirEnhanced);

var _File = require('../File');

var _File2 = _interopRequireDefault(_File);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Clean extends _Rule2.default {

  run() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const scrub = _this.command === 'scrub';
      const generatedFiles = new _set2.default();
      const files = new _set2.default();
      const directories = new _set2.default();

      if (scrub) {
        directories.add(_this.resolvePath('$NAME-cache.yaml'));
      }

      for (const rule of _this.rules) {
        if (rule.options.jobName === _this.options.jobName) {
          for (const file of rule.outputs) {
            if (file.virtual) continue;
            if (scrub) {
              files.add(file);
            } else {
              generatedFiles.add(file);
            }
          }
        }
      }

      for (const pattern of _this.options.cleanPatterns) {
        if (/^[/\\]/.test(pattern)) {
          for (const matchedFilePath of yield _this.globPath(pattern.substring(1))) {
            const filePath = _path2.default.resolve(_this.rootPath, matchedFilePath);
            if (yield _File2.default.isFile(filePath)) {
              const file = yield _this.getFile(matchedFilePath);
              if (file) files.add(file);
            } else if (yield _File2.default.isDirectory(filePath)) {
              directories.add(filePath);
            }
          }
        } else if (!scrub && generatedFiles.size !== 0) {
          const isMatch = _micromatch2.default.matcher(_this.resolvePath(pattern), { dot: true });
          for (const file of generatedFiles.values()) {
            if (isMatch(file.filePath)) {
              files.add(file);
            }
          }
        }
      }

      for (const file of files.values()) {
        yield _this.state.deleteFile(file, _this.options.jobName);
      }

      for (const filePath of directories) {
        yield _File2.default.remove(_path2.default.resolve(_this.rootPath, filePath));
        _this.emit('fileDeleted', { type: 'fileDeleted', file: filePath });
      }

      const candidateDirectories = yield (0, _fastGlob2.default)('**/*', { cwd: _this.rootPath, onlyDirs: true, bashNative: [] });
      candidateDirectories.reverse();

      for (const filePath of candidateDirectories) {
        const realFilePath = _path2.default.resolve(_this.rootPath, filePath);
        const contents = yield _readdirEnhanced2.default.async(realFilePath);
        if (contents.length === 0) {
          yield _File2.default.remove(realFilePath);
          _this.emit('fileDeleted', { type: 'fileDeleted', file: filePath });
        }
      }

      return true;
    })();
  }
}
exports.default = Clean;
Clean.commands = new _set2.default(['clean', 'scrub']);
Clean.alwaysEvaluate = true;
Clean.description = 'Clean up a previous build.';