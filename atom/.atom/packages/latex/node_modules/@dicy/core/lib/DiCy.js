'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _maxSafeInteger = require('babel-runtime/core-js/number/max-safe-integer');

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readdirEnhanced = require('readdir-enhanced');

var _readdirEnhanced2 = _interopRequireDefault(_readdirEnhanced);

var _State = require('./State');

var _State2 = _interopRequireDefault(_State);

var _StateConsumer = require('./StateConsumer');

var _StateConsumer2 = _interopRequireDefault(_StateConsumer);

var _File = require('./File');

var _File2 = _interopRequireDefault(_File);

var _Rule = require('./Rule');

var _Rule2 = _interopRequireDefault(_Rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VALID_COMMAND_PATTERN = /^(build|clean|graph|load|log|save|scrub)$/;

class DiCy extends _StateConsumer2.default {
  static create(filePath, options = {}) {
    return (0, _asyncToGenerator3.default)(function* () {
      const schema = yield DiCy.getOptionDefinitions();
      const state = new _State2.default(filePath, schema);
      const builder = new DiCy(state, state.getJobOptions());

      yield builder.initialize();
      yield builder.setInstanceOptions(options);

      state.assignOptions(options);

      return builder;
    })();
  }

  initialize() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const ruleClassPath = _path2.default.join(__dirname, 'Rules');
      const entries = yield _readdirEnhanced2.default.async(ruleClassPath);
      _this.state.ruleClasses = entries.map(function (entry) {
        return require(_path2.default.join(ruleClassPath, entry)).default;
      });
    })();
  }

  setInstanceOptions(options = {}) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const instance = yield _this2.getFile('dicy-instance.yaml-ParsedYAML');
      if (instance) instance.value = options;
    })();
  }

  analyzePhase(command, phase) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this3.checkForKill();

      for (const ruleClass of _this3.ruleClasses) {
        const jobNames = ruleClass.ignoreJobName ? [null] : _this3.options.jobNames;
        for (const jobName of jobNames) {
          const rule = yield ruleClass.analyzePhase(_this3.state, command, phase, _this3.state.getJobOptions(jobName));
          if (rule) {
            yield _this3.addRule(rule);
          }
        }
      }
    })();
  }

  analyzeFiles(command, phase) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this4.checkForKill();

      while (true) {
        const file = (0, _from2.default)(_this4.files).find(function (file) {
          return !file.analyzed;
        });

        if (!file) break;

        for (const ruleClass of _this4.ruleClasses) {
          const jobNames = file.jobNames.size === 0 ? [null] : (0, _from2.default)(file.jobNames.values());
          for (const jobName of jobNames) {
            const rules = yield ruleClass.analyzeFile(_this4.state, command, phase, _this4.state.getJobOptions(jobName), file);
            for (const rule of rules) {
              yield _this4.addRule(rule);
            }
          }
        }

        file.analyzed = true;
      }
    })();
  }

  getAvailableRules(command) {
    return this.ruleClasses.filter(rule => !command || rule.commands.has(command)).map(rule => ({ name: rule.name, description: rule.description }));
  }

  evaluateRule(rule, action) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this5.checkForKill();

      if (rule.failures.has(action)) {
        _this5.info(`Skipping rule ${rule.id} because of previous failure.`);
        return false;
      }

      yield rule.evaluate(action);
      return true;
    })();
  }

  evaluate(command, phase, action) {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this6.checkForKill();

      const primaryCount = function (ruleGroup) {
        return ruleGroup.reduce(function (total, rule) {
          return total + rule.parameters.reduce(function (count, parameter) {
            return parameter.filePath === _this6.filePath ? count + 1 : count;
          }, 0);
        }, 0);
      };
      const evaluationNeeded = function (rule) {
        return rule.actions.has(action) && rule.command === command && rule.phase === phase;
      };

      // First separate the rule graph into connected components. For each
      // component only retain rules that are pertinent to the current command,
      // phase and action. Rank the rules in the component by the number of other
      // rules that it is directly dependent on within the same component. Only
      // retain those that have the lowest dependency rank. Sort the remaining
      // rules by number of inputs in an ascending order. Finally sort the
      // components by number of primaries in an ascending order. A rule is
      // considered a primary is it has as an input the main source file for that
      // job. Note: we are using lodash's sortBy because the standard sort is
      // not guaranteed to be a stable sort.
      const rules = _lodash2.default.flatten(_lodash2.default.sortBy(_this6.components.map(function (component) {
        const ruleGroup = _lodash2.default.sortBy(component.filter(evaluationNeeded), [function (rule) {
          return rule.inputs.length;
        }]);

        return ruleGroup.reduce(function (current, rule) {
          // Rank the rule by how many other rules it is directly dependent on.
          const rank = ruleGroup.reduce(function (count, otherRule) {
            return _this6.isGrandparentOf(rule, otherRule) ? count + 1 : count;
          }, 0);

          // The rank is lower than the current rank so start a new list.
          if (rank < current.rank) return { rank, rules: [rule]
            // The ranks is the same as the current rank so just add us to the
          };if (rank === current.rank) current.rules.push(rule);
          // list.

          return current;
        }, { rank: _maxSafeInteger2.default, rules: [] }).rules;
      }), [primaryCount]));

      if (rules.length === 0) return false;

      let didEvaluation = false;

      for (const rule of rules) {
        yield _this6.checkUpdates(command, phase);
        didEvaluation = (yield _this6.evaluateRule(rule, action)) || didEvaluation;
      }

      yield _this6.checkUpdates(command, phase);

      return didEvaluation;
    })();
  }

  checkUpdates(command, phase) {
    var _this7 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this7.checkForKill();

      for (const file of _this7.files) {
        for (const rule of _this7.state.getInputRules(file)) {
          yield rule.addFileActions(file, command, phase);
        }
        file.hasBeenUpdated = false;
      }
    })();
  }

  kill(message = 'Build was killed.') {
    if (!this.killToken) return _promise2.default.resolve();

    if (!this.killToken.promise) {
      this.killToken.error = new Error(message);
      this.killToken.promise = new _promise2.default(resolve => {
        // $FlowIgnore
        this.killToken.resolve = resolve;
        this.killChildProcesses();
      });
    }

    return this.killToken.promise;
  }

  run(...commands) {
    var _this8 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (_this8.killToken) {
        _this8.error('Build currently in progress');
        return false;
      }

      const invalidCommands = commands.filter(function (command) {
        return !VALID_COMMAND_PATTERN.test(command);
      });
      if (invalidCommands.length !== 0) {
        _this8.error(`Aborting due to receiving the following invalid commands: ${invalidCommands.join(', ')}`);
        return false;
      }

      _this8.killToken = {};

      let success = true;

      try {
        for (const command of commands) {
          for (const phase of ['initialize', 'execute', 'finalize']) {
            yield _this8.runPhase(command, phase);
          }
        }
        success = (0, _from2.default)(_this8.rules).every(function (rule) {
          return rule.failures.size === 0;
        });
      } catch (error) {
        success = false;
        _this8.error(error.stack);
      } finally {
        if (_this8.killToken && _this8.killToken.resolve) {
          success = false;
          _this8.killToken.resolve();
        }
        _this8.killToken = null;
      }

      return success;
    })();
  }

  runPhase(command, phase) {
    var _this9 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this9.checkForKill();

      for (const file of _this9.files) {
        file.hasBeenUpdated = file.hasBeenUpdatedCache;
        file.analyzed = false;
      }

      for (const rule of _this9.rules) {
        yield rule.phaseInitialize(command, phase);
      }

      yield _this9.analyzePhase(command, phase);

      for (let cycle = 0; cycle < _this9.options.phaseCycles; cycle++) {
        let didEvaluation = false;

        for (const action of ['parse', 'updateDependencies', 'run']) {
          yield _this9.analyzeFiles(command, phase);
          didEvaluation = (yield _this9.evaluate(command, phase, action)) || didEvaluation;
        }

        if ((0, _from2.default)(_this9.files).every(function (file) {
          return file.analyzed;
        }) && (0, _from2.default)(_this9.rules).every(function (rule) {
          return rule.command !== command || rule.phase !== phase || !rule.needsEvaluation;
        })) break;

        if (!didEvaluation) break;
      }
    })();
  }

  static getOptionDefinitions() {
    return (0, _asyncToGenerator3.default)(function* () {
      const filePath = _path2.default.resolve(__dirname, '..', 'resources', 'option-schema.yaml');
      const schema = yield _File2.default.readYaml(filePath, true);
      const options = [];
      for (const name in schema) {
        const option = schema[name];
        option.name = name;
        options.push(option);
      }
      return options;
    })();
  }

  updateOptions(options = {}, user = false) {
    var _this10 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const normalizedOptions = {};
      const filePath = _this10.resolvePath(user ? '$HOME/.dicy.yaml' : '$ROOTDIR/$NAME.yaml');

      if (yield _File2.default.canRead(filePath)) {
        const currentOptions = yield _File2.default.readYaml(filePath);
        _this10.state.assignSubOptions(normalizedOptions, currentOptions);
      }

      _this10.state.assignSubOptions(normalizedOptions, options);
      yield _File2.default.writeYaml(filePath, normalizedOptions);

      return normalizedOptions;
    })();
  }
}
exports.default = DiCy;