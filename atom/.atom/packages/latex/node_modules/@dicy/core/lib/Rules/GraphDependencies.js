'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _File = require('../File');

var _File2 = _interopRequireDefault(_File);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const COMMAND_PHASE_JOB_NAME_PATTERN = /\(([^;)]*);([^;)]*);([^;)]*);?/;

class GraphDependencies extends _Rule2.default {

  run() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let lines = [];
      const rulesByCommand = _lodash2.default.groupBy((0, _from2.default)(_this.state.rules.values()), function (rule) {
        return rule.command;
      });
      let level = 0;

      function addLine(line) {
        lines.push(_lodash2.default.repeat(' ', 2 * level) + line);
      }

      function startGraph(name, label) {
        if (name && label) {
          addLine(`subgraph "cluster_${name}" {`);
          level++;
          addLine(`label = "${label}";`);
        } else {
          addLine('digraph {');
        }
      }

      function endGraph() {
        level--;
        addLine('}');
      }

      startGraph();

      for (const command in rulesByCommand) {
        startGraph(command, `${command} command`);
        const rulesByPhase = _lodash2.default.groupBy(rulesByCommand[command], function (rule) {
          return rule.phase;
        });
        for (const phase in rulesByPhase) {
          switch (phase) {
            case 'execute':
              addLine(`"cluster_${command};initialize" -> "cluster_${command};execute";`);
              break;
            case 'finalize':
              addLine(`"cluster_${command};execute" -> "cluster_${command};finalize";`);
              break;
          }
          startGraph(`${command};${phase}`, `${phase} phase`);
          const rulesByJobName = _lodash2.default.groupBy(rulesByPhase[phase], function (rule) {
            return rule.options.jobName;
          });
          for (const jobName in rulesByJobName) {
            if (jobName !== 'undefined') {
              startGraph(`${command};${phase};${jobName}`, `\\"${jobName}\\" job`);
            }
            const rules = rulesByJobName[jobName] || [];
            for (let i = 0; i < rules.length; i++) {
              // let connected = false
              for (let j = 0; j < rules.length; j++) {
                const from = _this.isGrandparentOf(rules[i], rules[j]);
                const to = _this.isGrandparentOf(rules[j], rules[i]);

                if (from) {
                  if (!to) {
                    addLine(`"${rules[i].id}" -> "${rules[j].id}";`);
                  } else if (i <= j) {
                    addLine(`"${rules[i].id}" -> "${rules[j].id}" [dir="both"];`);
                  }
                }
              }
              addLine(`"${rules[i].id}" [shape=box,label="${rules[i].id.replace(COMMAND_PHASE_JOB_NAME_PATTERN, '(')}"];`);
            }
            if (jobName !== 'undefined') endGraph();
          }
          endGraph();
        }
        endGraph();
      }

      endGraph();

      const filePath = _this.resolvePath('$NAME-graph.dot');
      yield _File2.default.write(filePath, lines.join('\n'));
      yield _this.getOutput(filePath);

      return true;
    })();
  }
}
exports.default = GraphDependencies;
GraphDependencies.commands = new _set2.default(['graph']);
GraphDependencies.alwaysEvaluate = true;
GraphDependencies.ignoreJobName = true;
GraphDependencies.description = 'Creates a GraphViz dependency graph.';