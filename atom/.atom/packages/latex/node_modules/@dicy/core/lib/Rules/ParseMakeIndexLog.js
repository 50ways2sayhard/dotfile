'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MESSAGE_PATTERN = /^\s+--\s*(.*)$/;

class ParseMakeIndexLog extends _Rule2.default {

  parse() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const output = yield _this.getResolvedOutput('$FILEPATH_0-ParsedMakeIndexLog');
      if (!output) return false;

      const name = 'makeindex';
      const parsedLog = {
        messages: [],
        inputs: [],
        outputs: [],
        calls: []
      };

      yield _this.firstParameter.parse([{
        names: ['input'],
        patterns: [/^Scanning (?:style|input) file (.*?)[.]+done .*$/],
        evaluate: function (reference, groups) {
          parsedLog.inputs.push(_this.normalizePath(groups.input));
          parsedLog.messages.push({
            severity: 'info',
            name,
            text: groups._,
            log: reference
          });
        }
      }, {
        names: ['output'],
        patterns: [/^(?:Output|Transcript) written in (.*?)\.*$/],
        evaluate: function (reference, groups) {
          parsedLog.outputs.push(_this.normalizePath(groups.output));
          parsedLog.messages.push({
            severity: 'info',
            name,
            text: groups._,
            log: reference
          });
        }
      }, {
        names: ['text'],
        patterns: [/^(Nothing written in .*?\.)$/],
        evaluate: function (reference, groups) {
          parsedLog.messages.push({
            severity: 'warning',
            name,
            text: groups.text,
            log: reference
          });
        }
      }, {
        names: ['text'],
        patterns: [/^(Sorting entries.*)$/],
        evaluate: function (reference, groups) {
          parsedLog.messages.push({
            severity: 'info',
            name,
            text: groups.text,
            log: reference
          });
        }
      }, {
        names: ['inputPath', 'inputLine', 'outputPath', 'outputLine', 'text'],
        patterns: [/## Warning \(input = (.+), line = (\d+); output = (.+), line = (\d+)\):/, MESSAGE_PATTERN],
        evaluate: function (reference, groups) {
          const line = parseInt(groups.inputLine, 10);
          parsedLog.messages.push({
            severity: 'warning',
            name: 'makeindex',
            text: groups.text,
            log: reference,
            source: {
              file: groups.inputPath,
              range: {
                start: line,
                end: line
              }
            }
          });
        }
      }, {
        names: ['category', 'file', 'line', 'text'],
        patterns: [/^[*!]+ (Input (?:index|style)) error \(file = (.+), line = (\d+)\):$/, MESSAGE_PATTERN],
        evaluate: function (reference, groups) {
          const line = parseInt(groups.line, 10);
          parsedLog.messages.push({
            severity: 'error',
            name: 'makeindex',
            text: groups.text,
            category: groups.category,
            log: reference,
            source: {
              file: groups.file,
              range: {
                start: line,
                end: line
              }
            }
          });
        }
      }]);

      output.value = parsedLog;

      return true;
    })();
  }
}
exports.default = ParseMakeIndexLog;
ParseMakeIndexLog.parameterTypes = [new _set2.default(['MakeIndexLog'])];
ParseMakeIndexLog.commands = new _set2.default(['build', 'log']);
ParseMakeIndexLog.defaultActions = ['parse'];
ParseMakeIndexLog.description = 'Parses any logs generated by makeindex.';