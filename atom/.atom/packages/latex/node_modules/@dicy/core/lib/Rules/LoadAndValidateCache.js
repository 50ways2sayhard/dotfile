'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _File = require('../File');

var _File2 = _interopRequireDefault(_File);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

var _types = require('../types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LoadAndValidateCache extends _Rule2.default {

  initialize() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this.cacheFilePath = _this.resolvePath('$ROOTDIR/$NAME-cache.yaml');
    })();
  }

  run() {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (_this2.options.loadCache) {
        if ((yield _File2.default.canRead(_this2.cacheFilePath)) && (!_this2.state.cacheTimeStamp || _this2.state.cacheTimeStamp < (yield _File2.default.getModifiedTime(_this2.cacheFilePath)))) {
          _this2.info('Loading build cache from disk as it is newer then in-memory build cache.');
          yield _this2.loadCache();
        } else {
          if (_this2.options.validateCache) {
            _this2.info('Validating in-memory build cache.');
            yield _this2.validateCache();
          } else {
            _this2.info('Skipping cache validation since `validateCache` is not set.');
          }
        }
      } else {
        _this2.info('Skipping loading build cache from disk since `loadCache` is not set.');
        _this2.cleanCache();
      }

      // Get the main source file just in case it wasn't added by the cache load.
      // This also lets the cache load test for a change in the main source file.
      yield _this2.getFile(_this2.filePath);

      return true;
    })();
  }

  cleanCache() {
    for (const jobName of this.options.jobNames) {
      for (const file of this.files) {
        this.state.deleteFile(file, jobName, false);
      }
    }
  }

  loadCache() {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this3.cleanCache();

      _this3.state.cacheTimeStamp = yield _File2.default.getModifiedTime(_this3.cacheFilePath);
      const cache = yield _File2.default.readYaml(_this3.cacheFilePath);

      if (!cache) return true;

      if (!cache.version) {
        _this3.warning('Skipping load of build cache since no version tag was found in the cache.');
      } else if (!_semver2.default.satisfies(cache.version, `^${_types.CACHE_VERSION}`)) {
        _this3.warning(`Skipping load of build cache since version tag \`v${cache.version}\` does not match \`^${_types.CACHE_VERSION}\`.`);
        return true;
      }

      _this3.state.assignOptions(cache.options);

      if (cache.files) {
        for (const filePath in cache.files) {
          yield _this3.state.getFile(filePath, cache.files[filePath]);
        }
      }

      if (cache.rules) {
        for (const rule of cache.rules) {
          yield _this3.state.addCachedRule(rule);
        }
      }
    })();
  }

  validateCache() {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const files = [];

      for (const file of _this4.files) {
        if (!file.virtual) {
          if (yield file.canRead()) {
            yield file.update();
          } else {
            files.push(file);
          }
        }
      }

      for (const jobName of _this4.options.jobNames) {
        for (const file of files) {
          _this4.state.deleteFile(file, jobName, false);
        }
      }

      for (const rule of _this4.rules) {
        for (const input of rule.inputs) {
          yield rule.addFileActions(input);
        }
      }
    })();
  }
}
exports.default = LoadAndValidateCache;
LoadAndValidateCache.phases = new _set2.default(['initialize']);
LoadAndValidateCache.commands = new _set2.default(['load']);
LoadAndValidateCache.alwaysEvaluate = true;
LoadAndValidateCache.ignoreJobName = true;
LoadAndValidateCache.description = 'Loads the file/rule cache from a previous build.';