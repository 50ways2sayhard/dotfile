'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _File = require('../File');

var _File2 = _interopRequireDefault(_File);

var _Log = require('../Log');

var _Log2 = _interopRequireDefault(_Log);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

var _State = require('../State');

var _State2 = _interopRequireDefault(_State);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MakeIndex extends _Rule2.default {

  static isApplicable(state, command, phase, options, parameters = []) {
    return (0, _asyncToGenerator3.default)(function* () {
      const parsedLog = parameters[1].value;
      const base = _path2.default.basename(parameters[0].filePath);
      const messagePattern = new RegExp(`(Using splitted index at ${base}|Remember to run \\(pdf\\)latex again after calling \`splitindex')`);
      const wasGeneratedBySplitIndex = state.isOutputOf(parameters[0], 'SplitIndex');
      const splitindexCall = !!parsedLog && !!_Log2.default.findCall(parsedLog, 'splitindex', base);
      const splitindexMessage = !!parsedLog && !!_Log2.default.findMessage(parsedLog, messagePattern);

      // Avoid makeindex if there is any evidence of splitindex messages in the
      // log or splitindex calls unless this index control file was generated
      // by splitindex.
      return wasGeneratedBySplitIndex || !splitindexMessage && !splitindexCall;
    })();
  }

  initialize() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const ext = _path2.default.extname(_this.firstParameter.filePath);
      const firstChar = ext[1];
      const parsedLog = _this.secondParameter.value;

      // Automatically assign style based on index type.
      if (!_this.options.indexStyle) {
        switch (_this.firstParameter.type) {
          case 'NomenclatureControlFile':
            _this.options.indexStyle = 'nomencl.ist';
            break;
          case 'BibRefControlFile':
            _this.options.indexStyle = 'bibref.ist';
            break;
        }
      }

      // Automatically assign output path based on index type.
      if (!_this.options.indexOutputPath) {
        switch (_this.firstParameter.type) {
          case 'NomenclatureControlFile':
            _this.options.indexOutputPath = '$DIR_0/$NAME_0.nls';
            break;
          case 'BibRefControlFile':
            _this.options.indexOutputPath = '$DIR_0/$NAME_0.bnd';
            break;
          default:
            _this.options.indexOutputPath = `$DIR_0/$NAME_0.${firstChar}nd`;
            break;
        }
      }

      // Automatically assign log path based on index type.
      if (!_this.options.indexLogPath) {
        // .brlg instead of .blg is used as extension to avoid ovewriting any
        // Biber/BibTeX logs.
        _this.options.indexLogPath = `$DIR_0/$NAME_0.${firstChar === 'b' ? 'br' : firstChar}lg`;
      }

      if (parsedLog) {
        const { base } = _path2.default.parse(_this.firstParameter.filePath);
        let call = _Log2.default.findCall(parsedLog, /^(makeindex|texindy|mendex|upmendex)$/, base);

        if (!call) {
          call = _Log2.default.findMessageMatches(parsedLog, /after calling `((?:makeindex|texindy|mendex|upmendex)[^']*)'/).map(function (match) {
            return _Log2.default.parseCall(match[1], 'gronk');
          }).find(function (call) {
            return call.args.includes(base);
          });
        }

        if (call) {
          switch (call.args[0]) {
            case 'makeindex':
            case 'texindy':
            case 'mendex':
            case 'upmendex':
              _this.options.indexEngine = call.args[0];
              break;
            default:
              _this.info(`Ignoring unknown index engine \`${call.args[0]}\``);
          }
          _this.options.indexCompressBlanks = !!call.options.c;
          _this.options.indexAutomaticRanges = !call.options.r;
          _this.options.indexOrdering = call.options.l ? 'letter' : 'word';
          if ('t' in call.options) {
            _this.options.indexLogPath = call.options.t;
          }
          if ('o' in call.options) {
            _this.options.indexOutputPath = call.options.o;
          }
          if ('p' in call.options) {
            _this.options.indexStartPage = call.options.p;
          }
          if ('s' in call.options) {
            _this.options.indexStyle = call.options.s;
          }
          switch (call.args[0]) {
            case 'makeindex':
              if (call.options.g) {
                _this.options.indexSorting = 'german';
              } else if (call.options.T) {
                _this.options.indexSorting = 'thai';
              } else if (call.options.L) {
                _this.options.indexSorting = 'locale';
              } else {
                _this.options.indexSorting = 'default';
              }
              break;
            case 'mendex':
              if (call.options.E) {
                _this.options.kanji = 'euc';
              } else if (call.options.J) {
                _this.options.kanji = 'jis';
              } else if (call.options.S) {
                _this.options.kanji = 'sjis';
              } else if (call.options.U) {
                _this.options.kanji = 'utf8';
              }

              if (call.options.I) {
                _this.options.kanjiInternal = call.options.I;
              }
            // fall through
            case 'upmendex':
              if (call.options.d) {
                _this.options.indexDictionary = call.options.d;
              }

              if (call.options.f) {
                _this.options.indexForceKanji = true;
              }

              break;
          }
        }
      }
    })();
  }

  getFileActions(file) {
    return (0, _asyncToGenerator3.default)(function* () {
      // Only return a run action for the actual idx file and updateDependencies
      // for the parsed makeindex log.
      switch (file.type) {
        case 'ParsedMakeIndexLog':
        case 'ParsedMendexLog':
        case 'ParsedXindyLog':
          return ['updateDependencies'];
        case 'ParsedLaTeXLog':
          return [];
        default:
          return ['run'];
      }
    })();
  }

  preEvaluate() {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!_this2.actions.has('run')) return;

      const parsedLog = _this2.secondParameter.value;
      const { base, ext } = _path2.default.parse(_this2.firstParameter.filePath);
      const engine = _this2.options.indexEngine;

      // If the correct makeindex call is found in the log then delete the run
      // action.
      if (parsedLog) {
        const call = _Log2.default.findCall(parsedLog, engine, base, 'executed');
        if (call) {
          _this2.info(`Skipping ${engine} call since ${engine} was already executed via shell escape.`);
          const firstChar = ext[1];

          yield _this2.getResolvedOutputs([call.options.t ? `$DIR_0/${call.options.t}` : `$DIR_0/$NAME_0.${firstChar}lg`, call.options.o ? `$DIR_0/${call.options.o}` : `$DIR_0/$NAME_0.${firstChar}nd`]);

          _this2.actions.delete('run');
        }
      }
    })();
  }

  constructCommand() {
    const texindy = this.options.indexEngine === 'texindy';
    const mendex = this.options.indexEngine === 'mendex';
    const upmendex = this.options.indexEngine === 'upmendex';
    const makeindex = this.options.indexEngine === 'makeindex';
    const logPath = this.options.indexLogPath || '$DIR_0/$NAME_0.ilg';
    const outputPath = this.options.indexOutputPath || '$DIR_0/$NAME_0.ind';
    const parsedLogName = texindy ? 'ParsedXindyLog' : makeindex ? 'ParsedMakeIndexLog' : 'ParsedMendexLog';
    const infoIgnoreSetting = name => {
      this.info(`Ignoring \`${name}\` setting of \`${this.options[name].toString()}\` since index engine \`${this.options.engine}\` does not support that option or setting.`);
    };

    const args = [this.options.indexEngine, '-t', `{{${logPath}}}`, '-o', `{{${outputPath}}}`];

    if (this.options.indexStyle) {
      if (texindy) {
        infoIgnoreSetting('indexStyle');
      } else {
        args.push('-s', this.options.indexStyle);
      }
    }

    // Remove blanks from index ids
    if (this.options.indexCompressBlanks) {
      if (texindy) {
        infoIgnoreSetting('indexCompressBlanks');
      } else {
        args.push('-c');
      }
    }

    // Ignore spaces in grouping.
    if (this.options.indexOrdering === 'letter') {
      args.push('-l');
    }

    if (this.options.indexSorting !== 'default') {
      // It is possible to have all of these enabled at the same time, but
      // inspection of the makeindex code seems to indicate that `thai` implies
      // `locale` and that `locale` prevents `german` from being used.
      if (makeindex) {
        switch (this.options.indexSorting) {
          case 'german':
            args.push('-g');
            break;
          case 'thai':
            args.push('-T');
            break;
          case 'locale':
            args.push('-L');
            break;
        }
      } else if (texindy && this.options.indexSorting === 'german') {
        args.push('-g');
      } else {
        infoIgnoreSetting('indexSorting');
      }
    }

    // Specify the starting page.
    if (this.options.indexStartPage) {
      if (texindy) {
        infoIgnoreSetting('indexStartPage');
      } else {
        args.push('-p', this.options.indexStartPage);
      }
    }

    // Prevent automatic range construction.
    if (!this.options.indexAutomaticRanges) {
      args.push('-r');
    }

    if (this.options.kanji) {
      if (mendex) {
        // mendex doesn't have all of the encodings in the kanji or the
        // kanjiInternal setting, but we at least try here.
        switch (this.options.kanji) {
          case 'euc':
            args.push('-E');
            break;
          case 'jis':
            args.push('-J');
            break;
          case 'sjis':
            args.push('-S');
            break;
          case 'utf8':
            args.push('-U');
            break;
          default:
            infoIgnoreSetting('kanji');
            break;
        }
      } else {
        infoIgnoreSetting('kanji');
      }
    }

    if (this.options.kanjiInternal) {
      if (mendex && (this.options.kanjiInternal === 'euc' || this.options.kanjiInternal === 'utf8')) {
        args.push('-I', this.options.kanjiInternal);
      } else {
        infoIgnoreSetting('kanjiInternal');
      }
    }

    if (this.options.indexForceKanji) {
      // Both mendex and upmendex allow forcing kanji.
      if (mendex || upmendex) {
        args.push('-f');
      } else {
        infoIgnoreSetting('indexForceKanji');
      }
    }

    if (this.options.indexDictionary) {
      // Both mendex and upmendex have a sorting based on pronounciation.
      if (mendex || upmendex) {
        args.push('-d', `{{${this.options.indexDictionary}}}`);
      } else {
        infoIgnoreSetting('indexDictionary');
      }
    }

    args.push('{{$FILEPATH_0}}');

    const commandOptions = {
      args,
      cd: '$ROOTDIR',
      severity: 'error',
      inputs: [`${logPath}-${parsedLogName}`],
      outputs: [outputPath, logPath]
    };

    if (mendex || upmendex) {
      commandOptions.stderr = '$DIR_0/$NAME_0.log-MendexStdErr';
    }

    return commandOptions;
  }
}
exports.default = MakeIndex;
MakeIndex.parameterTypes = [new _set2.default(['IndexControlFile', 'BibRefControlFile', 'NomenclatureControlFile']), new _set2.default(['ParsedLaTeXLog'])];
MakeIndex.description = 'Runs makeindex on any index files.';